name: Build Android Kernel (Non-GKI)

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout kernel source
      uses: actions/checkout@v4
      with:
        repository: LineageOS/android_kernel_lge_sdm845
        ref: lineage-22.2
        path: kernel
        fetch-depth: 1
        
    - name: Setup build environment
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          bc bison build-essential ccache curl flex g++-multilib \
          gcc-multilib git gnupg gperf imagemagick lib32readline-dev \
          lib32z1-dev liblz4-tool libncurses5-dev libssl-dev \
          libxml2 libxml2-utils lzop pngcrush rsync schedtool \
          squashfs-tools xsltproc zip zlib1g-dev unzip python3 \
          python-is-python3 openjdk-11-jdk
          
    - name: Download toolchains
      run: |
        mkdir -p $GITHUB_WORKSPACE/toolchain
        cd $GITHUB_WORKSPACE/toolchain
        # Clang
        git clone https://github.com/LineageOS/android_prebuilts_clang_kernel_linux-x86_clang-r416183b \
          -b lineage-20.0 clang --depth=1
        # GCC (aarch64 and arm32)
        git clone https://github.com/LineageOS/android_prebuilts_gcc_linux-x86_aarch64_aarch64-linux-android-4.9 \
          -b lineage-19.1 gcc64 --depth=1
        git clone https://github.com/LineageOS/android_prebuilts_gcc_linux-x86_arm_arm-linux-androideabi-4.9 \
          -b lineage-19.1 gcc32 --depth=1
          
    - name: Integrate KernelSU for Non-GKI (Manual Hook Mode)
      run: |
        cd kernel
        
        # Use KernelSU v0.9.5 which has better non-GKI support
        curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -s v0.9.5
        
        # The setup script should have created KernelSU directory
        if [ -d "KernelSU" ]; then
          echo "✓ KernelSU integrated successfully"
          ls -la KernelSU/
        else
          echo "✗ KernelSU integration failed"
          exit 1
        fi
        
        # KernelSU should auto-patch for non-GKI, but let's verify
        echo "=== Checking for KernelSU hooks ==="
        grep -r "ksu_handle_execveat" fs/exec.c || echo "No automatic hooks found - will need manual config"
        
    - name: Apply Non-GKI Manual Hooks (if needed)
      run: |
        cd kernel
        
        # Check if KernelSU already patched the files
        if grep -q "ksu_handle_execveat" fs/exec.c; then
          echo "✓ KernelSU hooks already present, skipping manual patch"
          exit 0
        fi
        
        echo "Applying manual hooks for 4.9 kernel..."
        
        # For 4.9 kernels, we need to manually add hooks
        # Check the exact function signature in your kernel
        echo "=== Current do_execveat_common signature ==="
        grep -A 5 "do_execveat_common" fs/exec.c | head -10
        
        # Create a proper patch file
        cat > /tmp/ksu_exec.patch << 'PATCH'
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -1,6 +1,13 @@
 /*
  *  linux/fs/exec.c
  */
+#ifdef CONFIG_KSU
+extern bool ksu_execveat_hook;
+extern int ksu_handle_execveat(int *fd, struct filename **filename_ptr, 
+                               void *argv, void *envp, int *flags);
+extern int ksu_handle_execveat_sucompat(int *fd, struct filename **filename_ptr,
+                                        void *argv, void *envp, int *flags);
+#endif
 
 #include <linux/slab.h>
 #include <linux/file.h>
PATCH

        # Try to apply the patch
        patch -p1 < /tmp/ksu_exec.patch || echo "Header patch may have failed, continuing..."
        
        # Now add the actual hook call inside the function
        # Find the do_execveat_common function and add hook right after opening brace
        python3 << 'PYEOF'
import re

with open('fs/exec.c', 'r') as f:
    content = f.read()

# Find do_execveat_common function and add hook after the opening brace
pattern = r'(static int do_execveat_common\([^)]+\)\s*\{)'
replacement = r'\1\n#ifdef CONFIG_KSU\n\tif (unlikely(ksu_execveat_hook))\n\t\tksu_handle_execveat(&fd, &filename, &argv, &envp, &flags);\n\tksu_handle_execveat_sucompat(&fd, &filename, &argv, &envp, &flags);\n#endif\n'

content = re.sub(pattern, replacement, content, count=1)

with open('fs/exec.c', 'w') as f:
    f.write(content)

print("✓ Patched fs/exec.c with KSU hooks")
PYEOF

        echo "=== Verifying patch ==="
        grep -A 8 "do_execveat_common" fs/exec.c | head -15
        
    - name: Integrate SukiSU (Non-GKI Compatible)
      run: |
        cd kernel
        
        # SukiSU nongki version - better for older kernels
        curl -LSs "https://raw.githubusercontent.com/SukiSU-Ultra/SukiSU-Ultra/main/kernel/setup.sh" | bash -s nongki || echo "SukiSU nongki setup done"
        
        # Try susfs but it might not work on non-GKI
        curl -LSs "https://raw.githubusercontent.com/SukiSU-Ultra/SukiSU-Ultra/main/kernel/setup.sh" | bash -s susfs-main || echo "SUSFS setup attempted"
        
        # Clone susfs sources
        git clone https://gitlab.com/simonpunk/susfs4ksu.git susfs4ksu --depth=1 || true
        
        # Try to integrate susfs if sources are available
        if [ -d "susfs4ksu/kernel_patches" ]; then
          cp -r susfs4ksu/kernel_patches/include/linux/susfs.h include/linux/ 2>/dev/null || true
          cp -r susfs4ksu/kernel_patches/fs/susfs fs/ 2>/dev/null || true
          echo "SUSFS patches applied"
        fi
        
    - name: Configure kernel for Non-GKI KernelSU
      run: |
        cd kernel
        export ARCH=arm64
        export SUBARCH=arm64
        
        # Generate base config
        make O=out judyln_lao_com-perf_defconfig
        
        # Enable KernelSU with manual hooks (critical for non-GKI)
        scripts/config --file out/.config --enable CONFIG_KSU
        scripts/config --file out/.config --enable CONFIG_KSU_MANUAL_HOOK
        scripts/config --file out/.config --disable CONFIG_KSU_DEBUG
        
        # Enable required kernel features
        scripts/config --file out/.config --enable KALLSYMS
        scripts/config --file out/.config --enable KALLSYMS_ALL
        scripts/config --file out/.config --enable MODULES
        scripts/config --file out/.config --enable MODULE_UNLOAD
        
        # Overlayfs support (needed for some root features)
        scripts/config --file out/.config --enable OVERLAY_FS
        
        # Disable things that can cause issues
        scripts/config --file out/.config --disable EFI
        scripts/config --file out/.config --disable EFI_STUB
        scripts/config --file out/.config --disable RANDOMIZE_BASE
        
        # Security features that work with KernelSU
        scripts/config --file out/.config --enable SECURITY
        scripts/config --file out/.config --disable SECURITY_SELINUX_DEVELOP
        
        # Try to enable SUSFS if available
        scripts/config --file out/.config --enable CONFIG_KSU_SUSFS || true
        
        # Regenerate configuration
        make O=out ARCH=arm64 olddefconfig
        
        # Show KSU related config
        echo "=== KernelSU Configuration ==="
        grep -E "CONFIG_KSU|CONFIG_OVERLAY" out/.config || echo "KSU configs may not be present"
        
    - name: Build kernel
      run: |
        cd kernel
        export ARCH=arm64
        export SUBARCH=arm64
        export CLANGDIR=$GITHUB_WORKSPACE/toolchain/clang
        export GCCDIR64=$GITHUB_WORKSPACE/toolchain/gcc64
        export GCCDIR32=$GITHUB_WORKSPACE/toolchain/gcc32
        export PATH=$CLANGDIR/bin:$GCCDIR64/bin:$GCCDIR32/bin:$PATH
        export CLANG_TRIPLE=aarch64-linux-gnu-
        export CROSS_COMPILE=aarch64-linux-android-
        export CROSS_COMPILE_ARM32=arm-linux-androideabi-
        
        # Build with verbose output to catch errors
        make -j$(nproc) O=out ARCH=arm64 LLVM=1 2>&1 | tee build.log
        
    - name: Check build results
      run: |
        cd kernel
        echo "=== Build Results ==="
        ls -lh out/arch/arm64/boot/
        
        if [ -f "out/arch/arm64/boot/Image.gz-dtb" ]; then
          echo "✓ Image.gz-dtb created successfully"
        elif [ -f "out/arch/arm64/boot/Image" ]; then
          echo "✓ Image created (no dtb appended)"
        else
          echo "✗ No kernel image found!"
          exit 1
        fi
        
    - name: Prepare release files
      run: |
        mkdir -p release
        cd kernel/out/arch/arm64/boot/
        
        # Copy all possible kernel images
        cp Image.gz-dtb $GITHUB_WORKSPACE/release/ 2>/dev/null || true
        cp Image.gz $GITHUB_WORKSPACE/release/ 2>/dev/null || true
        cp Image $GITHUB_WORKSPACE/release/ 2>/dev/null || true
        cp dts/qcom/*.dtb $GITHUB_WORKSPACE/release/ 2>/dev/null || true
        
        cd $GITHUB_WORKSPACE/release
        ls -lh
        
    - name: Upload build log
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: build-log-${{ github.run_number }}
        path: kernel/build.log
        
    - name: Upload kernel artifacts
      uses: actions/upload-artifact@v4
      with:
        name: kernel-nongki-ksu-${{ github.run_number }}
        path: release/*
